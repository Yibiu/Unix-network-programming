# 第三章 套接字编程简介

[TOC]



## 一：套接字地址结构

地址结构用于保存各种协议类型的地址。

### 1.1 IPv4 套接字地址结构

```c++
struct in_addr {
	in_addr_t s_addr;
};

struct sockaddr_in {
	uint8_t sin_len;		// length of struct(16 bytes)
	sa_family_t sin_family;	// AF_INET (8bits)
	in_port_t sin_port;		// 16bits port number
	struct in_addr sin_addr;// 32bits IPv4 address
	char sin_zero[8];		// unused
};
```

### 1.2 通用套接字地址结构

```c++
struct sockaddr {
	uint8_t sa_len;
	sa_family_t sa_family;	// address family:AF_XXX value
	char sa_data[14];		// protocl-specific address
};
```

从应用程序开发人员的观点看，这些通用套接字地址结构的唯一用途就是对指向特定于协议的套接字地址结构的指针执行类型强制转换。

### 1.3 IPv6套接字地址结构

```c++
struct in6_addr {
	uint8_t s6_addr[16];		// 128bits IPv6 address(network byte ordered)
};

#define SIN6_LEN
struct sockaddr_in6 {
	uint8_t sin6_len;			// length of this struct(28bytes)
	sa_family_t sin6_family;	// AF_INET6
	in_port_t sin6_port;		// transport layer port(network byte ordered)
	uint32_t sin6_flowinfo;		// flow information, undefined
	struct in6_addr sin6_addr;	// IPv6 address(network byte ordered)
	uint32_t sin6_scope_id;		// set of interfaces for a scope
};
```

### 1.4 新通用套接字地址结构

新的通用套接字地址结构既支持IPv4又支持IPv6：

```c++
struct sockaddr_storage {
	uint8_t ss_len;			// length of this struct(implementation dependent)
	sa_family_t ss_family;	// address family:AF_XXX value
	
	// implementation
	// ...
};
```





## 二：字节序

- 小端字节序：将低序字节存储在起始地址；
- 大端字节序：将高序字节存储在起始地址；
- 主机字节序：某个给定系统的字节序，系统相关；
- 网络字节序：网络传输指定的字节序。

###2.1 字节序查询

```c++
#include ...

int main(int argc, char *argv[])
{
	union {
 		short s;
    	char c[sizeof(short)];
	} un;
	un.s = 0x0102;
	printf("%s: ", CPU_VENDOR_OS);
	if (un.c[0] == 0x01 && un.c[1] == 0x02) {
		printf("big-endian\n");
	}
	else if (un.c[0] == 0x02 && un.c[1] == 0x01) {
    	printf("little-endian\n");
	}
	else {
    	printf("unknown\n");
	}
  
 	return 0;
}
```

### 2.2 字节序转换

主机字节序和网络字节序转换：

```c++
#include <netinet/in.h>

uint16_t htons(uint16_t host16bitvalue);
uint32_t htonl(uint32_t host32bitvalue);
uint16_t ntohs(uint16_t net16bitvalue);
uint32_t ntohl(uint32_t net32bitvalue);
```





## 三：字节操作

有两组字节操作函数：4.2BSD和ANSI C：

```c++
// 4.2BSD
#include <strings.h>

void bzero(void *dest, size_t nbytes);
void bcopy(const void *src, void *dest, size_t nbytes);
int bcmp(const void *ptrl, const void *ptr2, size_t nbytes);

// ANSI C
#include <string.h>
void *memset(void *dest, int c, size_t len);
void *memcpy(void *dest, const void *src, size_t nbytes);
int memcmp(const void *ptrl, const void *ptr2, size_t nbytes);
```





## 四：地址转换

点分十进制与网络字节序二进制之间的转换。（eg：192.168.2.80 -> 1342351552）

### 4.1 IPv4支持

```c++
#include <arpa/inet.h>

int inet_aton(const char *strptr, struct in_addr *addrptr);	// 成功返回1，否则返回0
in_addr_t inet_addr(const char *strptr);// 成功返回32位二进制网络字节序IPv4地址，否则INADDR_NONE
char *inet_ntoa(struct in_addr inaddr);	// 返回点分十进制数串指针
```

### 4.2 IPv4和IPv6支持

```c++
#include <arpa/inet.h>

int inet_pton(int family, const char *strptr, void *addrptr);
const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);

#define INET_ADDRSTRLEN		16
#define INET6_ADDRSTRLEN	46
```





























